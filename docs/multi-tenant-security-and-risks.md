# マルチテナント構成：批判的視点・セキュリティと実装リスク

設計案（`multi-tenant-design.md`）について、実装の難しさとセキュリティ／侵入リスクの観点で整理したドキュメントです。

---

## 1. セキュリティ上の懸念と対策方針

### 1.1 テナント分離の破綻（クロステナントデータ漏洩）

**リスク**  
あるテナントの利用者が、別テナントのセミナー・予約・管理者情報にアクセスできる状態になる。

**起こりうる原因**

| 原因 | 説明 |
|------|------|
| **テナントを渡し忘れ** | API や lib で「どのテナントのマスターか」を指定せず、デフォルトや固定のマスターを参照してしまう。 |
| **ID のみで取得** | `seminar_id` や `reservation_id` だけを信頼し、テナントを検証しない。UUID は他テナントと重複しうるため、別テナントのデータを返す可能性がある。 |
| **URL の tenant を信頼しすぎる** | クライアントが `/whgc-seminars` にいるときに、API を `/whgc-seminars/api/...` で呼んでも、サーバー側でパス上のテナントを**必ず検証**しないと、パスを改ざんされた場合に別テナント扱いされる。 |

**対策**

- **常に「テナント + ID」で一意に扱う**: セミナー取得・予約取得・削除などは、**URL の `[tenant]` と `[id]` の両方**を使う。サーバー側では「この tenant のマスターにこの id が存在するか」を確認してから返す。
- **テナントのホワイトリスト**: 許可するテナントを `["whgc-seminars", "kgri-pic-center", "aff-events", "pic-courses"]` に固定し、それ以外の `[tenant]` は 404 にする。未検証の文字列をそのままスプレッドシートIDの取得に使わない。
- **API の入り口で検証**: `/[tenant]/api/...`（例: `/whgc-seminars/api/seminars`）のハンドラの先頭で、パス上のテナントを 4 値のホワイトリストで検証し、不正なら即 400/404 を返す。検証後の tenant だけを `getMasterSpreadsheetId(tenant)` などに渡す。

---

### 1.2 IDOR（Insecure Direct Object Reference）

**リスク**  
`seminar_id` や `reservation_id` を推測・列挙され、他テナントのデータが返る。

**現状**  
セミナーIDは UUID で推測は困難だが、**どのテナントに属するか**は ID からは分からない。  
「この ID はテナントAのもの」と決めつけず、**必ず「リクエストで指定された tenant のマスターだけを参照」**する必要がある。

**対策**

- 取得・更新・削除はすべて「tenant のマスター／セミナー用シート」に限定する。  
  `findMasterRowById(id)` を **tenant に紐づくマスター** に対してだけ実行する（`getMasterSpreadsheetId(tenant)` で取得したIDのシートのみ）。
- レスポンスに他テナントの ID や内部識別子を出さない。エラーメッセージも「存在しません」程度に留め、どのテナントにデータがあるかは漏らさない。

---

### 1.3 管理画面の権限（管理者が別）

**リスク**  
テナントAの管理者が、URL を `/kgri-pic-center/admin/...` に変えるだけでテナントBのデータを操作できる。

**対策**

- 管理画面は **各テナント配下**（`/[tenant]/admin`）に置く。認証・セッションに **テナントを紐づける**。  
  例: JWT の payload に `tenant` を含める、またはセッションに「ログインしたテナント」を保存する。
- リクエストのパス（どのテナントの admin にいるか）と、**ログインしているテナント**が一致するかサーバー側で検証する。一致しなければ 403。
- テナント切り替えは「そのテナントの管理URLにアクセスしてからログイン」など、意図的な操作に限定する。

---

### 1.4 予約番号検索（/booking/manage）

**リスク**  
予約番号はテナントごとのマスターに分散するため、「予約番号だけ」で検索すると、  
- 全テナントを順に検索する必要があり、遅い・コストが高い  
- または「どのテナントか」をユーザーに入力させないと一意に決まらない  

さらに、予約番号を入力したテナントと、実際にデータがあるテナントが一致しているかを検証しないと、他テナントの予約詳細が見える可能性がある。

**対策**

- 予約管理ページを **各テナント配下** に置く: `/whgc-seminars/manage` のように「このテナントの予約番号のみ検索」とする。  
  または、予約番号入力時に「どのイベント（テナント）の予約か」を選択させる。
- 検索時は **そのテナントのマスターの「予約番号インデックス」だけ**を参照する。他テナントは検索しない。
- 予約詳細表示時も「この tenant のマスターにこの reservation_id が存在するか」を確認してから返す。

---

### 1.5 入力値としての [tenant]（パストラバーサル・インジェクション）

**リスク**  
`[tenant]` を未検証のままファイルパスや外部リソースの識別子に使うと、パストラバーサルやインジェクションの余地がある。

**対策**

- テナントは **固定のホワイトリスト** と照合するだけにし、それ以外は一切使わない。
- 環境変数名の組み立てに `tenant` を**そのまま**使わない。  
  `TENANT_${tenant}_MASTER_SPREADSHEET_ID` のような動的キーは避け、  
  `tenant === "whgc-seminars" ? process.env.TENANT_WHGC_SEMINARS_MASTER_SPREADSHEET_ID : ...` のように分岐するか、  
  tenant → 設定オブジェクトの Map で取得する。

---

### 1.6 エラーメッセージ・ログからの情報漏洩

**リスク**  
エラーに「スプレッドシートID」「テナント名」「内部パス」を含めると、攻撃者に構造を教える。

**対策**

- ユーザー向けエラーは「お探しのページが見つかりません」「処理に失敗しました」程度に留める。
- 詳細はサーバーログにのみ出力し、本番ではログのアクセスを制限する。

---

## 2. 実装が難しそうな点

### 2.1 フロント：パス・API の一貫して「テナント付き」にすること

**課題**  
現在、多くの箇所で **`/seminars` や `/api/seminars` がハードコード**されている。  
テナント導入後は、**4つのパスをそれぞれハードコード**（`/whgc-seminars`, `/kgri-pic-center`, `/aff-events`, `/pic-courses`）し、各テナント配下のページではそのテナント用のパス・API を使う必要がある。

**該当しそうな箇所の例**

| 種類 | 現状の例 | テナント対応後のイメージ（例: whgc-seminars） |
|------|----------|-----------------------------------------------|
| 一覧へのリンク | `href="/seminars"`, `router.replace("/seminars")` | `href="/whgc-seminars"`, `router.replace("/whgc-seminars")` |
| 詳細・予約・管理 | `href={/seminars/${id}/booking}` | `href={\`/whgc-seminars/${id}/booking\`}`（テナントごとにパスをハードコード） |
| API 呼び出し | `fetch("/api/seminars/"+id)` | `fetch(\`/whgc-seminars/api/seminars/${id}\`)`（パス順はテナント → api。テナントごとにハードコード） |
| 予約完了後の遷移 | `router.push(\`/seminars/${id}/confirmation?rid=...\`)` | `router.push(\`/whgc-seminars/${id}/confirmation?rid=...\`)` |

**難しさの理由**

- 公開・管理とも **動的 `[tenant]` は使わず 4 本をハードコード**するため、各テナント用のページ・コンポーネントで「自分はどのテナントか」がパスから決まる（例: `whgc-seminars` 配下なら `"whgc-seminars"`）。
- これらの呼び出しは **ページ・レイアウト・共有コンポーネント・クライアントコンポーネント** に散らばっている。**モーダル**は「ページ」ではないので、親から **props で tenant（またはベースパス）を受け取る**か、**React Context で現在の tenant を参照**する必要がある。
- 一か所でも **誤ったテナントのパス**を使ったり、**従来の `/seminars` のまま**にしたりすると、404・意図しないテナントの API・他テナントのデータ表示につながる。

**対策方針**

- **「現在のテナント」をパスから決める**: 各テナントは `app/whgc-seminars/...`, `app/kgri-pic-center/...` など別フォルダなので、その配下のレイアウトで `tenant`（例: `"whgc-seminars"`）を Context や props で渡す。
- **API パス・リンクはテナントごとにハードコード**: 4 テナント分のベースパス（`/whgc-seminars`, `/whgc-seminars/api` など。パス順はテナント → api）を定数化し、各テナントのページからはその定数を使うと漏れが減る。
- **リファクタ後に grep で漏れを確認する**: `"/seminars"`, `'/api/seminars'`, `\`/seminars/${`, `"/api/bookings"` などを検索し、テナント用パスに置き換わっているか確認する。

---

### 2.2 モーダル表示と「ページ表示」の違い（ご指摘の「不安」）

**現状の整理**

- 一覧は **サーバーで取得した `seminars`** を `SeminarListClient` に渡している。
- モーダルは **その一覧の中から `id` で選んだ 1 件**を表示しているだけで、  
  **モーダル表示の時点では `/api/seminars/[id]` は呼んでいない**（一覧データをそのまま使っている）。
- 一方、**予約フォーム**（`/seminars/[id]/booking`）や **管理・アンケート** などでは、  
  **`fetch(\`/api/seminars/${id}\`)` で詳細を取得している**ため、ここはテナント用 API パスに変える必要がある。

**テナント導入後のイメージ（4テナントをハードコード）**

- 一覧ページ: 例として `app/whgc-seminars/page.tsx` で `getPublishedSeminars("whgc-seminars")` を呼び、`seminars` を取得。  
  → その `seminars` は「whgc-seminars のマスター」に限定されている。
- モーダル: これまでどおり「渡された `seminars` の 1 件」を表示。  
  **データの出所は一覧と同じテナントなので、モーダル単体では追加の API は不要**。
- **リンクだけが問題**: モーダル内の「申し込む」などは `href={/seminars/${seminar.id}/booking}` のようになっているため、  
  テナント配下では `href={\`/whgc-seminars/${seminar.id}/booking\`}` のように **そのテナントのパスをハードコード**する必要がある。  
  → **モーダル（および一覧を表示しているクライアント）に、そのテナントのベースパス（または tenant キー）を渡す**必要がある。

**結論**

- 「モーダルだから別途 API で取得している」のではなく、**一覧データの再利用**なので、  
  テナント用一覧を渡せばモーダルのデータ整合性は取りやすい。
- 難しくなるのは、  
  - モーダル・カード・フッターなど **パスを組み立てているすべてのコンポーネントに、そのテナントのベースパス（または tenant）を渡す**こと、  
  - かつ **渡し忘れがないようにすること**。  
  → Context か props で「現在のテナント（またはベースパス）」を渡す設計にするとよい。

---

### 2.3 管理画面・予約管理（各テナント配下に配置）

**課題**

- `/admin/...`, `/booking/manage` は現状 **テナントの概念がない**。
- テナント導入後は、  
  - 管理: **`/[tenant]/admin`** の形で、4テナントそれぞれをハードコード（`/whgc-seminars/admin`, `/kgri-pic-center/admin` など）。認証と「今どのテナントを操作しているか」を紐づける。  
  - 予約管理: 各テナント配下（例: `/whgc-seminars/manage`）に置く。

**難しさ**

- 既存の `/admin` のレイアウト・サイドバー・リダイレクトを、  
  4テナント分の `app/whgc-seminars/admin/...`, `app/kgri-pic-center/admin/...` などに**それぞれ配置**する必要がある（動的 `[tenant]` は使わない）。
- ログイン時に「どのテナントの管理者か」は、アクセスした URL（どのテナントの `/admin` か）から決まり、そのテナントとログイン情報を照合する。

---

## 3. 侵入・エラーを許しそうなポイント（チェックリスト）

| # | 観点 | リスク | 対策 |
|---|------|--------|------|
| 1 | テナント未検証 | 不正な `[tenant]` で他テナントのマスターを参照 | ホワイトリスト照合を API の入り口で必ず実施 |
| 2 | ID のみで取得 | `seminar_id` だけで取得し、テナントを無視 | 必ず「tenant のマスター」に対してのみ ID 検索 |
| 3 | 管理画面のテナント | URL を変えるだけで他テナントを操作 | セッションの tenant とアクセスしたパス（どの /[tenant]/admin か）を照合し、不一致なら 403 |
| 4 | 予約番号検索 | 予約番号からテナントを特定せず全検索 or 他テナントを返す | 予約管理をテナント付きにし、そのテナントのインデックスのみ検索 |
| 5 | フロントのパス・API の漏れ | 一部だけ `/seminars` のまま → 404 または誤ったテナント | Context/props で tenant を共有し、パス・API はヘルパー経由にし、grep で漏れ確認 |
| 6 | 環境変数の動的参照 | `process.env["TENANT_"+tenant+"_..."]` でインジェクション | tenant はホワイトリストの値だけに限定し、キーは分岐 or Map で取得 |
| 7 | エラー・ログ | 内部IDやテナント名がユーザーに返る | ユーザー向けは汎用メッセージに限定 |

---

## 4. まとめ

- **セキュリティ**: 「テナント + ID」のセットでだけデータを扱うこと、テナントのホワイトリスト検証、管理画面のテナントとセッションの一致確認、予約番号のテナントスコープ化が重要。
- **実装の難しさ**: フロントの「パスと API をテナント付きに揃える」ことと、モーダル・共有コンポーネントに「現在の tenant」を渡す設計に集約される。モーダル自体は一覧データを表示しているだけなので、一覧をテナント付きにすればデータの齟齬は防ぎやすいが、**リンクと API 呼び出しの tenant の渡し忘れ**がバグとセキュリティの両方の原因になりうる。
- 実装時は、上記チェックリストを「テナント対応完了条件」として使うと、漏れとリスクを抑えやすい。
